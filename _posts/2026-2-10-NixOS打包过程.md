---
title: NixOS 打包过程
toc: true
categories:
  - 计算机
tags:
  - NixOS
  - Linux
---

这里记录在 NixOS 第一次自行打包软件的过程.

<!-- more -->

## 打包的基本流程

最近将笔记本的 EndeavourOS 替换成了 NixOS，NixOS 这一种不可变的无状态的具有函数式编程的特点的系统非常和我胃口. 不过由于其不可变的特性，也使得其不遵守 FHS 标准，它的 `/lib` 或 `/lib64` 目录下不存在类似 `ld-linux-x86-64.so.2` 之类的库文件动态加载器，更不存在 `libc.so` 之类的库文件。因此，除非静态链接，否则为其它 Linux 下编译的二进制文件将不能直接在 NixOS 上运行.

好在官方的 Nixpkgs 已经提供了大量软件的打包，很多软件都能直接写进配置文件中安装. 但总有少数软件并没有被 Nixpkgs 收录，这时就需要自己动手打包了.

在 Nix 中，所有的打包工作通常都是基于 `stdenv.mkDerivation` 这个标准环境进行的。它预定义了一套标准构建的流程. 当运行 `nix-build` 时，Nix 会创建一个完全隔离的沙盒环境，构建中使用的所有软件都需要在 `buildInputs` 和 `nativeBuildInputs` 里声明. 同时，整个构建过程除了 `fetchurl` / `fetchgit` 等固定哈希的下载步骤外，是无法访问网络的. 这些要求确保了构建的可复现性.

一个比较完整的构建流程如下：

- unpackPhase：解压源码或压缩包到临时目录
- patchPhase：针对软件的路径硬编码打补丁
- configurePhase：准备构建系统，运行 cmake 配置等
- buildPhase：编译
- installPhase：安装，将所有编译好的文件放在 `$out` 里. 只有在 `$out` 里的文件会被保留
- fixupPhase：编译后处理，修正动态库链接

以上每一个步骤都有默认的实现，`stdenv` 会自动按顺序执行每一个步骤，同时也可以根据需要重写它们.

一个简单的模板如下：

```nix
{ pkgs ? import <nixpkgs> {} }:

pkgs.stdenv.mkDerivation rec {
  pname = "app";
  version = "0.0.1";

  src = pkgs.fetchFromGitHub {
    owner = "username";
    repo = "repo-name";
    rev = "v${version}";
    sha256 = "0000000000000000000000000000000000000000000000000000";
  };

  nativeBuildInputs = [
    # 打包需要的构建工具 
  ];

  buildInputs = [
    # 运行时需要的库
  ];
  
  # 重写步骤 
  installPhase = ‘’
    # 以 installPhase 为例子. 安装时的命令.
  ‘’；

}
```

如果使用 Home Manager，则还需要加一层：

```nix
{ pkgs, ... }:
let
  app = pkgs.stdenv.mkDerivation rec { ... };
in
{
  home.packages = [ app ];
}
```

从而将构建好的包加入 `home.packages` 中.

## 打包文件解析

这里我希望安装笔记软件 [SpeedyNote](https://github.com/alpha-liu-01/SpeedyNote)，这个软件比较新，目前还没有被 Nixpkgs 收入. 一般而言，对于开源软件，一般打包脚本会从源码编译. 这里我偷懒直接使用 `.deb` 文件进行构建.

### 软件基本信息和文件下载

```nix
pname = "speedynote";
version = "1.2.1";
src = pkgs.fetchurl {
  url= "https://github.com/.../speedynote_1.2.1-1_amd64.deb";
  sha256 = "...";
};
```

打包软件的基本信息和构建需要的文件，不做过多解释.

### 构建依赖

```nix
nativeBuildInputs = with pkgs; [
  dpkg
  autoPatchelfHook
  qt6.wrapQtAppsHook
];
```

这里 `dpkg` 是用来提取 `.deb` 的.

`autoPatchelfHook` 是打包的核心工具，它会自动扫描二进制文件，把原本指向 `/usr/lib` 的动态库链接，替换为 NixOS 中对应的库路径（即下面 `buildInputs` 里提供的库）.

`qt6.wrapQtAppsHook` 则专门用于 Qt 程序，它会包裹二进制文件，设置 `QT_PLUGIN_PATH` 等环境变量，防止程序启动时报错.

### 运行时依赖

```nix
buildInputs = with pkgs; [
  stdenv.cc.cc.lib zlib qt6.qtbase ... libjpeg8 gumbo mujs ...
];
```

运行软件需要的动态库，不做过多解释.

### 解压与安装

```nix
unpackPhase = "dpkg -x $src .";

installPhase = ''
  mkdir -p $out
  cp -r usr/* $out/
  mkdir -p $out/lib
  
  ln -sf ${pkgs.gumbo}/lib/libgumbo.so $out/lib/libgumbo.so.2
  ln -sf ${pkgs.mujs}/lib/libmujs.so $out/lib/libmujs.so.3
'';
```

这里 `unpackPhase` 使用 `dpkg` 解压，之后在 `installPhase` 将解压的文件复制到 `$out`.

这里我们需要针对打包的路径进行一个修复. 原版 `.deb` 中的二进制文件被硬编码为寻找 `libgumbo.so.2` 和 `libmujs.so.3`，遵循 Debian 的命名习惯. 但 Nixpkgs 中的 `gumbo` 和 `mujs` 的名称是 `libgumbo.so` 等. 这里我们手动在 `$out/lib` 下创建名为 `.so.2` 和 `.so.3` 的假名，强行指向 Nixpkgs 里的真实库文件.

### 后期修复

```nix
postFixup = ''
  patchelf --add-rpath $out/lib $out/bin/speedynote
'';
```

这里我们使用 `autoPatchelfHook` 自动修复路径，注意需要添加我们手动引入的 `$out/lib`.
